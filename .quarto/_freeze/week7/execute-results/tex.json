{
  "hash": "d81f38680473c31850a59596c365bc14",
  "result": {
    "markdown": "# Some other data structures\n\n## Overview\n\nThis week we'll be covering different data structures:\n\n  - XML\n  - JSON\n  - unstructured (or semi-structured) text\n\n## XML\n\nExtensible Markup Language (XML) is a markup language that defines a set of rules for encoding documents in a format that is both human-readable and machine-readable. \n\nXML can serve as the basis for defining markup languages for particular domains. For example XBRL (Extensible Business Reporting Language), KML (Keyhole Markup Language for geographic information), BeerXML (you guessed it).\n\n\nHere is a simple example containing some data about my pets.\n\n```\n<pets>\n  <pet id = '001' species = 'dog'>\n    <tag>Rover</tag>\n    <colour>black</colour>\n  </pet>\n  <pet id = '002' species = 'cat'>\n    <tag>Tiddles</tag>\n    <colour>ginger</colour>\n  </pet>\n  <pet id = '003' species = 'dog'>\n    <tag>Fido</tag>\n    <colour>brownish</colour>\n  </pet>\n</pets>\n```\n\nEven if you knew nothing about XML before, you can work out what is going on.\n\n### Package `xml2`\n\nThe package `xml2` gives you tools to read an XML file and extract the data. \n\nhttps://blog.rstudio.com/2015/04/21/xml2/\n\nNormally you would read the data from an external file, but for a very small example I've saved the data above as a string called `my_pets`.\n\n\n\n\n\n\n\n### Navigating the tree\n\nIn XML everything is arranged in a tree structure, and each element is called a __node__.\n\nYou are familiar with a tree structure - just think of the way the files are organised on your computer: folders sit inside folders and each folder can contain other folders and files.\n\nIn a similar way, nodes sit inside nodes and each node can contain other nodes. The first node, that contains everything else, is the root node, and a node that doesn't contain any other nodes is called a leaf node.\n\nIn our example <pets>...</pets> is the root node, and the text strings \"Fido\", \"Brownish\" etc are leaf nodes.\n\nNodes can also contain __attributes__. For example the <pet>...</pet> nodes have \"id\" and \"species\" attributes.\n\nEvery node, except the root, has exactly one parent, and nodes can have children and siblings (nodes with the same parent).\n\nWe can use these concepts to navigate the tree.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nxpets <- read_xml(my_pets)\nxml_name(xpets)  # The name of the root node\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"pets\"\n```\n:::\n\n```{.r .cell-code}\nxml_child(xpets) # Finds the first child of the root (Rover)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n{xml_node}\n<pet id=\"001\" species=\"dog\">\n[1] <tag>Rover</tag>\n[2] <colour>black</colour>\n```\n:::\n\n```{.r .cell-code}\nxml_children(xpets) # Finds all the children of the root (Rover, Fido & Tibbles)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n{xml_nodeset (3)}\n[1] <pet id=\"001\" species=\"dog\">\\n  <tag>Rover</tag>\\n  <colour>black</colour ...\n[2] <pet id=\"002\" species=\"cat\">\\n  <tag>Tiddles</tag>\\n  <colour>ginger</col ...\n[3] <pet id=\"003\" species=\"dog\">\\n  <tag>Fido</tag>\\n  <colour>brownish</colo ...\n```\n:::\n\n```{.r .cell-code}\nxml_children(xpets) |> xml_name() # The name of each child\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"pet\" \"pet\" \"pet\"\n```\n:::\n\n```{.r .cell-code}\nxml_child(xpets) |> xml_siblings() # the siblings of Rover\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n{xml_nodeset (2)}\n[1] <pet id=\"002\" species=\"cat\">\\n  <tag>Tiddles</tag>\\n  <colour>ginger</col ...\n[2] <pet id=\"003\" species=\"dog\">\\n  <tag>Fido</tag>\\n  <colour>brownish</colo ...\n```\n:::\n\n```{.r .cell-code}\nxml_child(xpets) |> xml_parent() # The parent of Rover\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n{xml_node}\n<pets>\n[1] <pet id=\"001\" species=\"dog\">\\n  <tag>Rover</tag>\\n  <colour>black</colour ...\n[2] <pet id=\"002\" species=\"cat\">\\n  <tag>Tiddles</tag>\\n  <colour>ginger</col ...\n[3] <pet id=\"003\" species=\"dog\">\\n  <tag>Fido</tag>\\n  <colour>brownish</colo ...\n```\n:::\n\n```{.r .cell-code}\nxml_child(xpets) |> xml_child() # <tag> and <colour> are children of Rover\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n{xml_node}\n<tag>\n```\n:::\n:::\n\n\n\n### Searching\n\nWe can navigate and search through the tree with more precision using [XPath](https://www.w3schools.com/xml/xpath_syntax.asp){target=\"_blank\"}.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nxml_find_first(xpets, '//pet[@species=\"cat\"]') # Find the first cat\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n{xml_node}\n<pet id=\"002\" species=\"cat\">\n[1] <tag>Tiddles</tag>\n[2] <colour>ginger</colour>\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nxpets %>% \n      xml_find_all(\"//pet[@species='dog']\") %>% # List the dogs' names\n      xml_find_all(\".//tag\") %>%                # Note the important .\n      xml_text()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Rover\" \"Fido\" \n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nxpets %>%\n  xml_find_all(\".//pet[@species='dog']\") %>%\n  xml_attr(\"id\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"001\" \"003\"\n```\n:::\n:::\n\n\n\n### Create a data frame\n\nBy extracting each quantity we want separately we can put together a data frame.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npet_id <- \nxpets %>%\n  xml_find_all(\".//pet\") %>%\n  xml_attr(\"id\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\npet_species <- \nxpets %>%\n  xml_find_all(\".//pet\") %>%\n  xml_attr(\"species\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\npet_name <- \n  xpets %>% \n  xml_find_all(\".//pet/tag\") %>% \n  xml_text()\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\npet_colour <- \n  xpets %>% \n  xml_find_all(\".//pet/colour\") %>% \n  xml_text()\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndfpets <- \n  data.frame(ID = pet_id,\n             Name = pet_name,\n             Species = pet_species,\n             Colour = pet_colour)\ndfpets\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   ID    Name Species   Colour\n1 001   Rover     dog    black\n2 002 Tiddles     cat   ginger\n3 003    Fido     dog brownish\n```\n:::\n:::\n\n\n\n## JSON\n\n[JSON](https://en.wikipedia.org/wiki/JSON) is a syntax for storing and exchanging data. It's lightweight, human readable, language-independent and very widely used. Most programming languages can process JSON.\n\nTo see what JSON looks like we'll use the `jsonlite` package to convert our pets data from a data frame to JSON.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(jsonlite)\njpets <- toJSON(dfpets)\njpets\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[{\"ID\":\"001\",\"Name\":\"Rover\",\"Species\":\"dog\",\"Colour\":\"black\"},{\"ID\":\"002\",\"Name\":\"Tiddles\",\"Species\":\"cat\",\"Colour\":\"ginger\"},{\"ID\":\"003\",\"Name\":\"Fido\",\"Species\":\"dog\",\"Colour\":\"brownish\"}] \n```\n:::\n:::\n\n\n\nJSON stands for __JavaScript Object Notation__. The text inside each set of curly brackets represents a JavaScript object - but it is just text and can be taken to JSON is independent of JavaScript. You can think of each object as being like a card in an old-fashioned [card index system](https://www.popularmechanics.com/culture/a19379/a-short-history-of-the-index-card/).\n\n<a title=\"See page for author, Public domain, via Wikimedia Commons\" href=\"https://commons.wikimedia.org/wiki/File:A_man_working_on_the_card_index.png\"><img width=\"256\" alt=\"A man working on the card index\" src=\"https://upload.wikimedia.org/wikipedia/commons/thumb/9/9b/A_man_working_on_the_card_index.png/256px-A_man_working_on_the_card_index.png\"></a>\n\nWe can make it easier to read:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprettify((jpets))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[\n    {\n        \"ID\": \"001\",\n        \"Name\": \"Rover\",\n        \"Species\": \"dog\",\n        \"Colour\": \"black\"\n    },\n    {\n        \"ID\": \"002\",\n        \"Name\": \"Tiddles\",\n        \"Species\": \"cat\",\n        \"Colour\": \"ginger\"\n    },\n    {\n        \"ID\": \"003\",\n        \"Name\": \"Fido\",\n        \"Species\": \"dog\",\n        \"Colour\": \"brownish\"\n    }\n]\n \n```\n:::\n:::\n\n\n\n`jsonlite`has a function to convert to a data frame.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfromJSON(jpets)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   ID    Name Species   Colour\n1 001   Rover     dog    black\n2 002 Tiddles     cat   ginger\n3 003    Fido     dog brownish\n```\n:::\n:::\n\n\n\n## Text processing\n\nText processing (a branch of Natural Language Processing, or NLP) is a big topic and we can only scratch the surface in this module.\n\nIn Wednesday's class we will look at an example of sentiment analysis. \n\nWe'll use a list of English words rated for valence with an integer between minus five (negative) and plus five (positive). The words have been manually labeled by Finn Ã…rup Nielsen in 2009-2011.[@AFINN] but I have removed profanities from the list because I used it for a presentation in a school.\n\nWe'll also use some classic texts downloaded from [Project Gutenburg](www.gutenberg.org).\n\nPlease see the Further Reading for more information on text processing (and you'll probably want to refresh your regex skills).  \n\n\n## Reading\n\n  * XML\n    + [What is XML](https://www.ibm.com/developerworks/xml/tutorials/xmlintro/xmlintro.html) (Just the first bit)\n    + [Parse and process XML (and HTML) with xml2](https://blog.rstudio.com/2015/04/21/xml2/)\n  * JSON\n    + [Intro to JSON](https://www.digitalocean.com/community/tutorials/an-introduction-to-json)\n  \n## Further reading\n\n_Text Mining with R: a tidy approach_ [@silgeTTM] is an excellent introduction, compatible with the methods used in this course.\n\n## Check your understanding{.unnumbered}\n\n:::{.callout-tip collapse=\"true\"}\n## Convert the `starwars` data to JSON and examine the structure.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\njstarwars <- toJSON(starwars, pretty = TRUE)\n```\n:::\n\n\n:::\n\n:::{.callout-tip collapse=\"true\"}\n## Try converting back to a data frame and compare with the original.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndfstarwars <- fromJSON(jstarwars)\n\nidentical(starwars, dfstarwars)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n:::\n\n\n`identical()` returns FALSE. Can you work out why?\n:::",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {
      "knitr": [
        "{\"type\":\"list\",\"attributes\":{},\"value\":[]}"
      ]
    },
    "preserve": null,
    "postProcess": false
  }
}