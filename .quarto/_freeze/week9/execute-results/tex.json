{
  "hash": "1feb967042417598740bad894ef76c4e",
  "result": {
    "markdown": "# APIs\n\n## Overview\n\nThis week we'll be looking at [APIs](https://en.wikipedia.org/wiki/API)\n\n## Definitions\n\n### API\n\nAn application programming interface (API) is an interface or communication protocol between different parts of a computer program intended to simplify the implementation and maintenance of software. (Wikipedia)\n\n### REST\n\nRepresentational state transfer (REST) is a software architectural style that defines a set of constraints to be used for creating Web services. (Wikipedia)\n\nSpecifically, one of the restful rules is that that you should get data (called a resource) returned when you link to a specific URL.\n\nThe URL is called a __request__ and what is sent back is called a __response__.\n\nYou can use restful APIs to send as well as receive data, but we will only look at how to get data.\n\nThe API request can be included in a program - so you don't need a user to click on a _download_ link.\n\nAnother piece of jargon is __endpoint__. This is the base url for the API. This is followed by a __path__ that points to the exact resource.\n\nFinally we can have __query parameters__. These always begin with a ? and look like:\n\n`?query1=param1&query2=param2`\n\nwhere the & separates two query/parameter pairs.\n\nLet's have an example.\n\n## Example\n\nThe endpoint for Github is: `https://api.github.com`\n\nThe path to a specific user's repos is `/users/<username>/repos`.\n\nTry copying `https://api.github.com/users/vivait/repos` into your browser...\n\nyou should see information returned in JSON.\n\nBut we want to access the data in a program, not via a browser.\n\nThe package [`httr`](https://cran.r-project.org/web/packages/httr/vignettes/quickstart.html) provides tools for HTTP, including the verb GET:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\nlibrary(jsonlite)\nlibrary(httr)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ngithub_api <- function(path) {\n  url <- modify_url(\"https://api.github.com\", path = path)\n  GET(url)\n}\n\nresp <- github_api(\"/users/actuarial-science/repos\")\n```\n:::\n\n\n\nWe can use `jsonlite` to parse the content of the response into a useful R object.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrepos <- fromJSON(content(resp, \"text\"))\n```\n:::\n\n\n\nWe can add some parameters to our query\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nresp <- github_api(\"/users/vivait/repos?sort=updated&per_page=100\")\nrepos <- fromJSON(content(resp, \"text\"))\n```\n:::\n\n\n\nIn fact, if we know the request will return JSON, we can parse it directly with `jsonlite`. (Not advised in a program.)\n\nFor example, the Github documentation says _You can issue a GET request to the root endpoint to get all the endpoint categories that the REST API v3 supports_:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(fromJSON(\"https://api.github.com\"), 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$current_user_url\n[1] \"https://api.github.com/user\"\n\n$current_user_authorizations_html_url\n[1] \"https://github.com/settings/connections/applications{/client_id}\"\n\n$authorizations_url\n[1] \"https://api.github.com/authorizations\"\n\n$code_search_url\n[1] \"https://api.github.com/search/code?q={query}{&page,per_page,sort,order}\"\n\n$commit_search_url\n[1] \"https://api.github.com/search/commits?q={query}{&page,per_page,sort,order}\"\n\n$emails_url\n[1] \"https://api.github.com/user/emails\"\n\n$emojis_url\n[1] \"https://api.github.com/emojis\"\n\n$events_url\n[1] \"https://api.github.com/events\"\n\n$feeds_url\n[1] \"https://api.github.com/feeds\"\n\n$followers_url\n[1] \"https://api.github.com/user/followers\"\n```\n:::\n:::\n\n\n## Twitter example\n\n\n\n::: {.cell}\n\n:::\n\n\n\nThis code demonstrates how to use the `rtweet` package.\n\nFor more detail, see <https://cran.r-project.org/web/packages/rtweet/vignettes/intro.html>. \n\nFirst you'll need to set up a developer account with Twitter and get the access keys you need by creating a new app.\n\nFollow the instructions at: <https://cran.r-project.org/web/packages/rtweet/vignettes/auth.html>.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# library(rtweet)\n# ## authenticate - insert your app name and keys below\n# token <- create_token(\n#   app = \"R camlad\",\n#   consumer_key = api_key,\n#   consumer_secret = api_secret_key,\n#   access_token = access_token,\n#   access_secret = access_token_secret)\n```\n:::\n\n\n\n### Following a hashtag\n\nWe can search for tweets including a particular hashtag.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## search for tweets using the Cardano hashtag\n# rt <- search_tweets(\"#Cardano\", n = 100, include_rts = FALSE)\n# \n# ## preview tweets data\n# rt %>% select(id, text)\n```\n:::\n\n\n### Trending in Leicester\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# trnds <- get_trends(\"Leicester\")\n# trnds %>% \n#   select(trend, tweet_volume) %>% \n#   arrange(desc(tweet_volume))\n```\n:::\n\n\n\n### Get a particular user's timeline\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(stringr)\n# tmls <- get_timeline(\"leicspolice\", n = 100)\n# \n# tmls %>% \n#   select(created_at, text) %>% \n#   filter(str_detect(text, 'Traffic'))\n```\n:::\n\n\n\n## Accessing UK census (and other) data\n\nOur final example demonstrates the NOMIS API, which can be accessed through the `nomisr`[@nomisr] package.\n\n### A quick demonstration of using `nomisr` to extract data from the Nomis API\n\nThis example is based on the nomisr introduction [vignette](https://cran.r-project.org/web/packages/nomisr/vignettes/introduction.html)\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(nomisr)\n```\n:::\n\n\n\nFirst, we can download information on what data is available.\n\n\n\n::: {.cell hash='week9_cache/pdf/w9_nomisr_info_839875677c404fba5e59f2df529044d7'}\n\n```{.r .cell-code}\ndata_info <- nomis_data_info()\n#head(data_info)\nglimpse(data_info)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: 1,605\nColumns: 14\n$ agencyid                             <chr> \"NOMIS\", \"NOMIS\", \"NOMIS\", \"NOMIS~\n$ id                                   <chr> \"NM_1_1\", \"NM_2_1\", \"NM_4_1\", \"NM~\n$ uri                                  <chr> \"Nm-1d1\", \"Nm-2d1\", \"Nm-4d1\", \"Nm~\n$ version                              <dbl> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, ~\n$ annotations.annotation               <list> [<data.frame[10 x 2]>], [<data.f~\n$ components.attribute                 <list> [<data.frame[7 x 4]>], [<data.fr~\n$ components.dimension                 <list> [<data.frame[5 x 3]>], [<data.fr~\n$ components.primarymeasure.conceptref <chr> \"OBS_VALUE\", \"OBS_VALUE\", \"OBS_VA~\n$ components.timedimension.codelist    <chr> \"CL_1_1_TIME\", \"CL_2_1_TIME\", \"CL~\n$ components.timedimension.conceptref  <chr> \"TIME\", \"TIME\", \"TIME\", \"TIME\", \"~\n$ description.value                    <chr> \"Records the number of people cla~\n$ description.lang                     <chr> \"en\", \"en\", \"en\", \"en\", \"en\", \"en~\n$ name.value                           <chr> \"Jobseeker's Allowance with rates~\n$ name.lang                            <chr> \"en\", \"en\", \"en\", \"en\", \"en\", \"en~\n```\n:::\n:::\n\n\n\nThere's a lot here (`data_info` has 1605 rows). To dig deeper we can search the column `description.value` or `name.value` for key words.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npop_data_info <- \n  data_info %>% \n  filter(str_detect(name.value, \"(?i)population\")) %>% \n  select(id, name.value)\n\n#pop_data_info %>% head()\nglimpse(pop_data_info)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: 110\nColumns: 2\n$ id         <chr> \"NM_17_1\", \"NM_17_5\", \"NM_31_1\", \"NM_100_1\", \"NM_136_1\", \"N~\n$ name.value <chr> \"annual population survey\", \"annual population survey (vari~\n```\n:::\n:::\n\n\n\nSuppose we wanted population data for Leicester. It looks like \"NM_31_1\" might be worth investigating, so we can dig down deeper.\n\nThe data or is categorised first by \"concept\" (Read the docs at [nomis](https://www.nomisweb.co.uk/api/v01/help) if you want more details.)\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nid = \"NM_31_1\"\nnomis_get_metadata(id)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 x 3\n  codelist          conceptref isfrequencydimension\n  <chr>             <chr>      <chr>               \n1 CL_31_1_GEOGRAPHY GEOGRAPHY  false               \n2 CL_31_1_SEX       SEX        false               \n3 CL_31_1_AGE       AGE        false               \n4 CL_31_1_MEASURES  MEASURES   false               \n5 CL_31_1_FREQ      FREQ       true                \n6 CL_31_1_TIME      TIME       false               \n```\n:::\n:::\n\n\n\nGEOGRAPHY looks relevant, so we explore what \"types\" are available.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnomis_get_metadata(id, \"GEOGRAPHY\", type = \"type\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 26 x 3\n   id      label.en                                               description.en\n   <chr>   <chr>                                                  <chr>         \n 1 TYPE83  jobcentre plus group as of April 2019                  jobcentre plu~\n 2 TYPE84  jobcentre plus district as of April 2019               jobcentre plu~\n 3 TYPE342 english index of multiple deprivation 2010 - deciles   english index~\n 4 TYPE347 scottish index of multiple deprivation 2009 - deciles  scottish inde~\n 5 TYPE349 welsh index of multiple deprivation 2008 - deciles     welsh index o~\n 6 TYPE431 local authorities: county / unitary (as of April 2021) local authori~\n 7 TYPE432 local authorities: district / unitary (as of April 20~ local authori~\n 8 TYPE433 local authorities: county / unitary (as of April 2019) local authori~\n 9 TYPE434 local authorities: district / unitary (as of April 20~ local authori~\n10 TYPE442 combined authorities                                   combined auth~\n# i 16 more rows\n```\n:::\n:::\n\n\nFinally, we can choose a particular type and investigate it.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nid %>% \n  nomis_get_metadata(\"GEOGRAPHY\", type = \"TYPE446\") %>% \n  filter(str_detect(label.en, \"Leicester\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 x 4\n  id         parentCode label.en       description.en\n  <chr>      <chr>      <chr>          <chr>         \n1 1870659636 2013265924 Leicester      Leicester     \n2 1870659640 2013265924 Leicestershire Leicestershire\n```\n:::\n:::\n\n\nLooks like we've found what we want!\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nleics_pop <- \n  nomis_get_data(id = id, time = \"latest\",\n                 geography = c(\"1870659636\", \"1870659640\"))\n\nleics_pop %>% \n  select(DATE, GEOGRAPHY_NAME, SEX_NAME, AGE_NAME, MEASURES_NAME, OBS_VALUE) %>% \n  head(10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 10 x 6\n    DATE GEOGRAPHY_NAME SEX_NAME AGE_NAME           MEASURES_NAME OBS_VALUE\n   <dbl> <chr>          <chr>    <chr>              <chr>             <dbl>\n 1  2021 Leicester      Male     All ages           Value                NA\n 2  2021 Leicester      Male     All ages           Percent              NA\n 3  2021 Leicester      Male     Aged under 1 year  Value                NA\n 4  2021 Leicester      Male     Aged under 1 year  Percent              NA\n 5  2021 Leicester      Male     Aged 1 - 4 years   Value                NA\n 6  2021 Leicester      Male     Aged 1 - 4 years   Percent              NA\n 7  2021 Leicester      Male     Aged 5 - 9 years   Value                NA\n 8  2021 Leicester      Male     Aged 5 - 9 years   Percent              NA\n 9  2021 Leicester      Male     Aged 10 - 14 years Value                NA\n10  2021 Leicester      Male     Aged 10 - 14 years Percent              NA\n```\n:::\n:::\n\n\n\n\n## Homework\n\nInstall the package `randNames` and, using the instructions in the package documentation register for a free API key at randomapi.com.\n\nWrite a programme to download random data  for 400 imaginary users. What is the distribution of genders and country of origin in this data.\n\n### Optional Christmas Bonus question\n\nRegister an account at Advent of Code. For the **2020** competition solve Question 2. (The key to solving this elegantly is reading the data in and wrangling it into the best format to solve the problem.)\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {
      "knitr": [
        "{\"type\":\"list\",\"attributes\":{},\"value\":[]}"
      ]
    },
    "preserve": null,
    "postProcess": false
  }
}