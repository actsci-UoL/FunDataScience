{
  "hash": "bdb1b2f64be774e4169150402f6b114a",
  "result": {
    "markdown": "# Working with tidy data\n\n\n\n\n\n## Overview\n\nThis week we'll be examining the concept of tidy data and looking at how to pivot between different data formats.\n\nWe'll also be looking at an important method of searching and manipulating strings called [regular expressions](https://en.wikipedia.org/wiki/Regular_expression).\n\nBy the end of this week you'll be able to:\n\n1. Define the concept of tidy data and describe when it's useful\n2. Convert between narrower (tidy) data frames and wider ones using the functions in `tidyr`\n3. Describe the purpose and structure of a regular expression\n4. Use regular expressions in conjunction with the `stringr` package\n\nAs a special bonus, you'll be able to use regular expressions for searching inside Microsoft Office documents.\n\n## Tidy data\n\n[Tidy data](https://tidyr.tidyverse.org/) is data where:\n\n  - Every column is a variable.\n  - Every row is an observation..\n  - Every cell is a single value.\n  \nTidy data describes a standard way of storing data that is used wherever possible throughout the tidyverse. If you ensure that your data is tidy, you’ll spend less time fighting with the tools and more time working on your analysis.\n\nHowever, tidy data isn't always the best solution. In particular humans usually find wider data frames easier to take in and understand, so for presentation and data entry tasks the wider format is often best.\n\nHere's an example of a small tidy data set:\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 3\n  Name     Test   Score\n  <chr>   <int>   <dbl>\n1 Tiddles     1  0.0232\n2 Rover       1 -0.714 \n3 Tiddles     2  1.38  \n4 Rover       2  1.64  \n5 Tiddles     3 -1.53  \n6 Rover       3  1.15  \n```\n:::\n:::\n\n\nAnd here's the same data in a non-tidy (wide) format.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwide_df <- \n  tidy_df %>% \n    pivot_wider(names_from = Test, \n                names_prefix = \"Test_\", \n                values_from = Score)\n\nwide_df\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 × 4\n  Name     Test_1 Test_2 Test_3\n  <chr>     <dbl>  <dbl>  <dbl>\n1 Tiddles  0.0232   1.38  -1.53\n2 Rover   -0.714    1.64   1.15\n```\n:::\n:::\n\n\nThe functions in the `tidyverse` (notably `ggplot`) expect data in a tidy format but the wider format is often easier for people to read or to use when entering data.\n\nAs you've just seen, the `pivot_wider()` function takes us from tidy (aka \"longer\") format to a wider format. We can go back with `pivot_longer()`. Notice that the parameters are matched to those in the 'pivot wider()' example above.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwide_df %>% \n  pivot_longer(cols = !Name,              # Apply to all columns except Name\n               names_to = \"Test\",\n               names_prefix = \"Test_\",    # Remove this from the names.\n               values_to = \"Score\",\n               ) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 3\n  Name    Test    Score\n  <chr>   <chr>   <dbl>\n1 Tiddles 1      0.0232\n2 Tiddles 2      1.38  \n3 Tiddles 3     -1.53  \n4 Rover   1     -0.714 \n5 Rover   2      1.64  \n6 Rover   3      1.15  \n```\n:::\n:::\n\nFor more details, see the [pivot vignette](https://tidyr.tidyverse.org/articles/pivot.html).\n\n_Note: `pivot_wider()` and `pivot_longer()` replaced the previous functions `spread()` and `gather()`, which you may still see around._\n\n## Regular expressions\n\nRegular expressions can be thought of as a mechanism for advanced search. They provide a language for writing a pattern which is used to match occurrences withing a character string. This ability is made use of by functions in many different languages - in R we'll mainly use them in conjunction with the 'stringr' package.\n\nHere's a simple example. Suppose the string we want to search is \"Paul wrote this in 2020.\"\n\nThe simplest search would be to see if `target` contains the string \"Paul\", like this.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(stringr)\ntarget <- \"Paul wrote this in 2020.\"\ntarget %>% \n  str_detect(pattern = \"Paul\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\nOr we could extract the year contained in the target using a pattern that finds any string of exactly 4 digits.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntarget %>% \n  str_extract(pattern = \"\\\\d{4}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"2020\"\n```\n:::\n:::\n\n\nYou'll see that a regular expression (or regex) will often contain a special character like `\\\\d`, which matches any digit. The double backslash is a quirk of R. Most implementations of regular expressions only require a single backslash, so if you use any resource not written specifically for R you'll see `\\d` rather than `\\\\d`. \n\nIn fact (rather like SQL) there are minor differences in the implementation across different languages: something to bear in mind if you get stuck debugging some regex code.\n\nOur treatment in the lecture is by no means comprehensive - regular expressions can be considered a language in their own right. See:\n\n[Regular expressions](https://stringr.tidyverse.org/articles/regular-expressions.html)\n\nMy favourite quick reference is:\n\n[Regex Cheat Sheet](http://www.rexegg.com/regex-quickstart.html)\n\nFor `stringr` see:\n\n[Introduction to stringr](https://stringr.tidyverse.org/articles/stringr.html)\n\nThe university library has a book called _Mastering Regular Expressions_ [@FriedlMRE].\n\n## Reading\n\n_R for Data Science_ [@wickhamR4DS]:\n\n  - Chapter 12 _Tidy data_\n\n_R Programming for Data Science_ [@pengRP4DS]:\n\n  - Chapter 13 _Control structures_\n  - Chapter 14 _Functions_\n  - Chapter 17 _Regular expressions_\n  \n## Check your understanding{.unnumbered}\n\n:::{.callout-tip collapse=\"true\"}\n## In the regular expression \"\\\\d{4}\", why are there two backslashes?\n\nThis is a peculiarity of using regular expressions in R. The first backslash tells R to treat the second backslash as a 'backslash' and not a special character.\n:::\n\n\n:::{.callout-tip collapse=\"true\"}\n## What pattern would \"\\\\D{4}\" match?\n\nThis would match any four characters that are NOT digits. (See also w vs W - i.e. lower-case w vs upper-case W).\n:::\n\n:::{.callout-tip collapse=\"true\"}\n## In the world of regular expressions, what does \"greedy\" mean?\n\nA greedy expression matches the longest possible pattern it can find in the target. A lazy expression takes the first matching pattern it comes across (i.e. the shortest).\n\nFor example, here we try extracting 2 or more digits after the decimal point:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Greedy...\nstr_extract(\"The value of pi is 3.14159\", \"\\\\d\\\\.\\\\d{2,}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"3.14159\"\n```\n:::\n\n```{.r .cell-code}\n# Lazy (note the question mark)...\nstr_extract(\"The value of pi is 3.14159\", \"\\\\d\\\\.\\\\d{2,}?\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"3.14\"\n```\n:::\n:::\n\n:::",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}