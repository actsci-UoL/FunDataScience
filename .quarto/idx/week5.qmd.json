{"title":"Joining tables","markdown":{"headingText":"Joining tables","containsRefs":false,"markdown":"\n<a title=\"Metropolitan Museum of Art\n, CC0, via Wikimedia Commons\" href=\"https://commons.wikimedia.org/wiki/File:Roundel_with_Three_Apes_Building_a_Trestle_Table_MET_DT6459.jpg\"><img width=\"256\" alt=\"Roundel with Three Apes Building a Trestle Table MET DT6459\" src=\"https://upload.wikimedia.org/wikipedia/commons/thumb/b/b1/Roundel_with_Three_Apes_Building_a_Trestle_Table_MET_DT6459.jpg/256px-Roundel_with_Three_Apes_Building_a_Trestle_Table_MET_DT6459.jpg\"></a>\n\n## Overview\n\nThis week we'll be looking at how to combine different tables of data.\n\nBy the end of this chapter you'll be able to:\n\n1. Joint data frames using `dplyr::bind_rows()` or `dplyr::bind_cols()`\n2. Describe and use the following `dplyr` mutating joins:\n  + `left_join()`\n  + `right_join()`\n  + `inner_join()`\n  + `full_join()`\n3. Describe and use the following `dplyr` filtering joins:\n  + `semi_join()`\n  + `anti_join()`\n\n## Joining Tables\n\nIt's a common problem to have to combine data contained in two different tables. (We'll always assume in R that we are referring to data frames when we talk about a table - although there are other table-like structures)\n\n### Binding rows\n\nOne simple case is when we have two tables with identical columns and we want to \"stick\" one onto the bottom of the other. In Excel this is often done by cutting and pasting, which is a very dangerous method since it's so easy to lose rows.\n\nIn R we do this using `dplyr::bind_rows()`. (This is the tidyverse equivalent of `rbind()`.)\n\n```{r}\n#| label: w5_setup\n#| message: FALSE\nlibrary(dplyr)\nlibrary(stringr)\n# Split up mtcars\nall_cars <- mtcars |> arrange(wt)\nbig_cars <- filter(all_cars, wt > 3.5 )\nlittle_cars <- filter(all_cars, wt <= 3.5)\n\n# Recombine\ncombined_rows <- bind_rows(big_cars, little_cars) |> arrange(wt)\n\n# Test for equality\nidentical(all_cars, combined_rows)\n```\n\nA few things to note:\n\n  1. If one of the data frames has a column that isn't in the other, it will be filled with NAs in the output;\n  2. The columns don't have to be in the same order, they just have to have the same names;\n  3. If there are are duplicated rows in the inputs, they will be duplicated in the output (see `union()` for a way to avoid this if both data frames have identical columns);\n  4. `bind_rows()` can take any number of inputs - contained in a list;\n  5. If you are trying to join many data frames (inside a loop for example) it is much faster to collect them in a list and then bind them all at once, than it is to bind each one inside the loop.\n  6. You can use the `.id` parameter to record the source of each row (see `?bind_rows`).\n  7. The set functions `union()`, `intersect()` and `setdif()` can also be useful.\n  \n### Binding columns\n\nIf we have the same number of rows in two data frames we can add the columns using `bind_cols()`.\n\n```{r}\n#| label: w5_binding\n# Split up mtcars\ncars1 <- all_cars |> select(1:4)\ncars2 <- all_cars |> select(-(1:4))\n\n#Recombine\ncombined_cols <- bind_cols(cars1, cars2)\n\n# Test for equality\nidentical(all_cars, combined_cols)\n```\n## Mutating Joins\n\nThe following joins allow us to combine the data from two tables, creating extra columns as necessary.\n\nA nice feature of these `join_ functions is that their names and behaviour are similar to analogous functions for joining data in SQL, as we will see later in the programme.\n\nSuppose I have a table containing some details of students registered on a particular module. Perhaps it contains the student ID and a mark for a particular assignment.\n\n```{r}\n#| label: w5_make_data1\nset.seed(123)\nmarks <- \n  tibble(ID = 1:5,\n         Score = round(rnorm(5, mean = 65, sd = 10), 1))\n\nmarks$ID[5] <- 25\nmarks\n```\n\nI also have a table listing students and whether they are UG or PGT and their email address.\n\n```{r}\n#| label: w5_make_data2\ndetails <- \n  tibble( ID = 1:10,\n          Level = sample(c(\"UG\", \"PGT\"), size = 10, replace = TRUE)) |> \n  mutate(Email = str_c(\"stu\", ID, \"@univ.ac.uk\"))\n\nis.na(details$Email) <- 3\n\ndetails\n```\nNow suppose I want to add the email address to the first data frame. In Excel we could use something like  `vlookup` or `index/match`. In R we can use a `left_join()` which takes each row in the second table and adds the columns from the second if it finds a match. In my experience this is the most commonly used join.\n\n```{r}\n#| label: w5_left_join\nmarks |> \n  left_join(details, by = \"ID\")\n```\n\nIf you don't want the Level column it can be filtered out after the join.\n\n`right_join()` includes all the rows in the second table.\n\n```{r}\n#| label: w5_right_join\nmarks |> \n  right_join(details, by = \"ID\")\n```\n\nIn this case we end up with 10 rows (as in the `details` table.)\n\n`inner_join()` only matches rows that occur in both tables.\n\n```{r}\n#| label: w5_inner_join\nmarks |> \n  inner_join(details, by = \"ID\")\n```\nFinally, `full_join()` includes all rows in `marks` OR `details`.\n\n```{r}\n#| label: w5_full_join\nmarks |> \n  full_join(details, by = \"ID\")\n```\n\nNote that if the second table (`details`) contains more than one row that matches with ID in `marks` there will be more than one corresponding row in the output.\n\n```{r}\ndetails <- \n  details |> \n  bind_rows(tibble(ID = 4, Level = \"PGT\", Email = \"stu4@univ.ac.uk\"))\n```\n\n```{r}\nmarks |> \n  left_join(details, by = \"ID\")\n```\n### Filtering joins\n\nSometimes we want to remove rows from the first table, dependent on the contents of the second. For example we can use the information about student level in `details` to pick out any students with out a matching entry.\n\n```{r}\n#| label: w5_anti_join\nmarks |> \n  anti_join(details, by = \"ID\")\n```\n\nOr we can use a list of UG students (in this case generated by filtering `details`) to pick out the UG students in marks.\n\n```{r}\n#| label: w5_semi_join\nmarks |> \n  semi_join(details |> filter(Level ==\"UG\"), by = \"ID\")\n```\n## Summary\n\n**Mutating joins** add columns from y to x, matching rows based on the keys passed with the `by = ` parameter:\n\n`inner_join()` includes all rows in x and y.\n\n`left_join()` includes all rows in x.\n\n`right_join()` includes all rows in y.\n\n`full_join()` includes all rows in x or y.\n\nIf a row in x matches multiple rows in y, all the rows in y will be returned once for each matching row in x.\n\n**Filtering joins** filter rows from x based on the presence or absence of matches in y:\n\n`semi_join()` returns all rows from x with a match in y.\n\n`anti_join()` returns all rows from x without a match in y.\n\n## Reading\n\nR for Data Science [@wickhamR4DS]:\n\n  - _Chapter 13 Relational data_\n\n## Check your understanding{.unnumbered}\n\n:::{.callout-tip collapse=\"true\"}\n## What would you expect the output from `full_join(big_cars, little_cars)` to be?\n\n```{r}\n#| label: w5_check_understanding\nfull_join(big_cars, little_cars)\n```\n\n:::\n"},"formats":{"html":{"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"knitr"},"render":{"keep-tex":false,"keep-yaml":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":true,"link-external-newwindow":true,"self-contained-math":false,"format-resources":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","output-file":"week5.html"},"language":{},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.1.251","number-depth":2,"bibliography":["Z2-book.bib","Z3-packages.bib"],"biblio-style":"apalike","link-citations":"yes","description":"These are the course notes for the 2023 version of Fundamentals of Data Science </br>(MA7419 / MA3419)","theme":{"light":"flatly","dark":"darkly"}},"extensions":{"book":{"multiFile":true}}},"pdf":{"execute":{"fig-width":5.5,"fig-height":3.5,"fig-format":"pdf","fig-dpi":300,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"knitr"},"render":{"keep-tex":false,"keep-yaml":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"pdf","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":true,"merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"pdf-engine":"xelatex","standalone":true,"variables":{"graphics":true,"tables":true},"default-image-extension":"pdf","to":"pdf","output-file":"week5.pdf"},"language":{},"metadata":{"block-headings":true,"number-depth":2,"bibliography":["Z2-book.bib","Z3-packages.bib"],"biblio-style":"apalike","link-citations":"yes","description":"These are the course notes for the 2023 version of Fundamentals of Data Science </br>(MA7419 / MA3419)","documentclass":"scrreprt","papersize":"A4"},"extensions":{"book":{}}}}}